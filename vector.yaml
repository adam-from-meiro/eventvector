# vector.yaml - Clean configuration based on VRL examples
sources:
  ga_events:
    type: http_server
    address: "0.0.0.0:8080"
    path: "/collect"
    method: "POST"
    encoding: "json"

transforms:
  parse_and_validate:
    type: remap
    inputs: ["ga_events"]
    source: |
      # Validate required fields using VRL patterns from examples
      if !exists(.event) || is_nullish(.event) {
        log("Missing or null event field", level: "warn")
        abort
      }
      
      # Extract user identification with fallback chain (VRL example pattern)
      if exists(.userId) {
        .distinct_id = .userId
      } else if exists(.user_id) {
        .distinct_id = .user_id
      } else if exists(.anonymousId) {
        .distinct_id = .anonymousId
      } else if exists(.session_id) {
        .distinct_id = .session_id
      } else {
        .distinct_id = uuid_v4()
      }
      
      # Handle timestamp with multiple format support (from VRL examples)
      if exists(.timestamp) && is_string(.timestamp) {
        .timestamp = parse_timestamp(.timestamp, format: "%+") ?? 
                    parse_timestamp(.timestamp, format: "%Y-%m-%dT%H:%M:%S%.3fZ") ?? 
                    parse_timestamp(.timestamp, format: "%Y-%m-%dT%H:%M:%SZ") ?? 
                    now()
      } else {
        .timestamp = now()
      }
      
      # Initialize properties if missing (VRL safe pattern)
      if !exists(.properties) || !is_object(.properties) {
        .properties = {}
      }
      
      # Extract HTTP headers safely
      if exists(.headers) && is_object(.headers) {
        if exists(.headers."user-agent") && is_string(.headers."user-agent") {
          .properties.user_agent = .headers."user-agent"
        }
        if exists(.headers."x-forwarded-for") && is_string(.headers."x-forwarded-for") {
          .properties.ip_address = .headers."x-forwarded-for"
        }
        if exists(.headers.referer) && is_string(.headers.referer) {
          .properties.referrer = .headers.referer
        }
      }
      
      # Map common parameters
      if exists(.url) && is_string(.url) {
        .properties.current_url = .url
      }
      if exists(.value) {
        .properties.value = .value
      }
      if exists(.category) && is_string(.category) {
        .properties.category = .category
      }
      if exists(.label) && is_string(.label) {
        .properties.label = .label
      }

  format_for_posthog:
    type: remap
    inputs: ["parse_and_validate"]
    source: |
      # Get PostHog API key using proper VRL error handling
      api_key_value, err = get_env_var("POSTHOG_API_KEY")
      if err != null {
        log("Missing POSTHOG_API_KEY environment variable", level: "error")
        abort
      }
      
      # Create final PostHog event (based on VRL examples structure)
      . = {
        "api_key": api_key_value,
        "event": .event,
        "distinct_id": .distinct_id,
        "timestamp": format_timestamp!(.timestamp, format: "%+"),
        "properties": .properties
      }

sinks:
  posthog:
    type: http
    inputs: ["format_for_posthog"]
    uri: "https://app.posthog.com/capture/"
    method: "post"
    encoding:
      codec: "json"
    compression: "gzip"
    batch:
      max_events: 100
      timeout_secs: 1
    request:
      retry_attempts: 3
      retry_initial_backoff_secs: 1
      retry_max_duration_secs: 30
      timeout_secs: 30
    buffer:
      type: "memory"
      max_events: 1000
      when_full: "block"