# vector.yaml - Dual Routing: Marketing → PostHog, Analytics → Mixpanel
sources:
  ga_events:
    type: http_server
    address: "0.0.0.0:8080"
    path: "/collect"
    method: "POST"
    encoding: "json"

transforms:
  parse_and_validate:
    type: remap
    inputs: ["ga_events"]
    source: |
      # Validate required fields using VRL patterns from examples
      if !exists(.event) || is_nullish(.event) {
        log("Missing or null event field", level: "warn")
        abort
      }
      
      # Extract user identification with fallback chain (VRL example pattern)
      if exists(.userId) {
        .distinct_id = .userId
      } else if exists(.user_id) {
        .distinct_id = .user_id
      } else if exists(.anonymousId) {
        .distinct_id = .anonymousId
      } else if exists(.session_id) {
        .distinct_id = .session_id
      } else {
        .distinct_id = uuid_v4()
      }
      
      # Handle timestamp with multiple format support (from VRL examples)
      if exists(.timestamp) && is_string(.timestamp) {
        .timestamp = parse_timestamp(.timestamp, format: "%+") ?? 
                    parse_timestamp(.timestamp, format: "%Y-%m-%dT%H:%M:%S%.3fZ") ?? 
                    parse_timestamp(.timestamp, format: "%Y-%m-%dT%H:%M:%SZ") ?? 
                    now()
      } else {
        .timestamp = now()
      }
      
      # Initialize properties if missing (VRL safe pattern)
      if !exists(.properties) || !is_object(.properties) {
        .properties = {}
      }
      
      # Extract HTTP headers safely for PostHog system properties
      if exists(.headers) && is_object(.headers) {
        .http_context = {}
        if exists(.headers."user-agent") && is_string(.headers."user-agent") {
          .http_context.user_agent = .headers."user-agent"
        }
        if exists(.headers."x-forwarded-for") && is_string(.headers."x-forwarded-for") {
          .http_context.ip = .headers."x-forwarded-for"
        }
        if exists(.headers.referer) && is_string(.headers.referer) {
          .http_context.referrer = .headers.referer
        }
      }
      
      # Map common analytics parameters
      if exists(.url) && is_string(.url) {
        .properties.current_url = .url
      }
      if exists(.value) {
        .properties.value = .value
      }
      if exists(.category) && is_string(.category) {
        .properties.category = .category
      }
      if exists(.label) && is_string(.label) {
        .properties.label = .label
      }
      
      # Extract UTM parameters for marketing attribution
      if exists(.utm_source) && is_string(.utm_source) {
        .properties.utm_source = .utm_source
      }
      if exists(.utm_medium) && is_string(.utm_medium) {
        .properties.utm_medium = .utm_medium
      }
      if exists(.utm_campaign) && is_string(.utm_campaign) {
        .properties.utm_campaign = .utm_campaign
      }
      if exists(.utm_content) && is_string(.utm_content) {
        .properties.utm_content = .utm_content
      }
      if exists(.utm_term) && is_string(.utm_term) {
        .properties.utm_term = .utm_term
      }

  route_events:
    type: route
    inputs: ["parse_and_validate"]
    route:
      # MARKETING EVENTS → PostHog (Attribution, Sessions, Page Views)
      to_posthog: |
        .event == ("$" + "pageview") || .event == "pageview" ||
        .event == ("$" + "identify") || .event == "identify" ||
        .event == "Session Started" || .event == "session_started" ||
        .event == "Newsletter Signup" ||
        exists(.utm_source) ||
        (.event == "Purchase" && exists(.properties.utm_campaign))
      
      # ANALYTICS EVENTS → Mixpanel (Interactions, Features, E-commerce)
      to_mixpanel: |
        .event == "Button Clicked" || .event == "button_clicked" ||
        .event == "Form Submitted" || .event == "form_submitted" ||
        .event == "Product Added" || .event == "product_added" ||
        .event == "Purchase" || .event == "purchase" ||
        .event == "Feature Used" ||
        contains(string!(.event), "Click") || contains(string!(.event), "Submit")

  # PostHog Processing Pipeline
  enrich_for_posthog:
    type: remap
    inputs: ["route_events.to_posthog", "route_events._unmatched"]
    source: |
      # Event-specific transformations for PostHog (Marketing Focus)
      event_name = .event
      pageview_event = "$" + "pageview"
      identify_event = "$" + "identify"
      
      # PAGE VIEW EVENTS
      if event_name == pageview_event || event_name == "pageview" {
        .event = pageview_event
        .properties.event_category = "marketing"
        .properties.destination = "posthog"
        if exists(.properties.current_url) {
          .properties.page_url = .properties.current_url
        }
        if exists(.properties.page_title) && is_string(.properties.page_title) {
          .properties.title = .properties.page_title
        }
      }
      
      # USER IDENTIFICATION EVENTS
      if event_name == identify_event || event_name == "identify" {
        .event = identify_event
        .properties.event_category = "marketing"
        .properties.destination = "posthog"
        if exists(.traits) && is_object(.traits) {
          .properties = merge!(.properties, .traits)
        }
      }
      
      # SESSION EVENTS
      if event_name == "Session Started" || event_name == "session_started" {
        .event = "Session Started"
        .properties.event_category = "marketing"
        .properties.destination = "posthog"
        if exists(.session_id) {
          .properties.session_id = .session_id
        }
      }
      
      # MARKETING EVENTS
      if event_name == "Newsletter Signup" {
        .properties.event_category = "marketing"
        .properties.destination = "posthog"
      }
      
      # PURCHASE EVENTS (Marketing Attribution)
      if event_name == "Purchase" && exists(.properties.utm_campaign) {
        .properties.event_category = "marketing"
        .properties.destination = "posthog"
        .properties.attribution_focus = true
      }

  format_for_posthog:
    type: remap
    inputs: ["enrich_for_posthog"]
    source: |
      # Get PostHog API key using proper VRL error handling
      api_key_value, err = get_env_var("POSTHOG_API_KEY")
      if err != null {
        log("Missing POSTHOG_API_KEY environment variable", level: "error")
        abort
      }
      
      # Create PostHog event structure
      posthog_event = {
        "api_key": api_key_value,
        "event": .event,
        "distinct_id": .distinct_id,
        "timestamp": format_timestamp!(.timestamp, format: "%+"),
        "properties": .properties
      }
      
      # Add PostHog system properties using safe string concatenation
      if exists(.http_context) && is_object(.http_context) {
        if exists(.http_context.user_agent) {
          user_agent_key = "$" + "user_agent"
          posthog_event.properties = set!(posthog_event.properties, [user_agent_key], .http_context.user_agent)
        }
        
        if exists(.http_context.ip) {
          ip_key = "$" + "ip"
          posthog_event.properties = set!(posthog_event.properties, [ip_key], .http_context.ip)
        }
        
        if exists(.http_context.referrer) {
          referrer_key = "$" + "referrer"
          posthog_event.properties = set!(posthog_event.properties, [referrer_key], .http_context.referrer)
        }
      }
      
      # Convert current_url to PostHog format
      if exists(.properties.current_url) {
        current_url_key = "$" + "current_url"
        posthog_event.properties = set!(posthog_event.properties, [current_url_key], .properties.current_url)
        # Remove the original current_url field
        del(posthog_event.properties.current_url)
      }
      
      # Set the final event
      . = posthog_event

  # Mixpanel Processing Pipeline
  enrich_for_mixpanel:
    type: remap
    inputs: ["route_events.to_mixpanel"]
    source: |
      # Event-specific transformations for Mixpanel (Analytics Focus)
      event_name = .event
      
      # INTERACTION EVENTS
      if event_name == "Button Clicked" || event_name == "button_clicked" {
        .event = "Button Clicked"
        .properties.event_category = "analytics"
        .properties.destination = "mixpanel"
        .properties.interaction_type = "click"
        if exists(.properties.button_name) {
          .properties.element_text = .properties.button_name
        }
      }
      
      if event_name == "Form Submitted" || event_name == "form_submitted" {
        .event = "Form Submitted"
        .properties.event_category = "analytics"
        .properties.destination = "mixpanel"
        .properties.interaction_type = "form"
        if exists(.properties.form_name) {
          .properties.form_id = .properties.form_name
        }
      }
      
      # E-COMMERCE EVENTS
      if event_name == "Product Added" || event_name == "product_added" {
        .event = "Product Added"
        .properties.event_category = "analytics"
        .properties.destination = "mixpanel"
        .properties.ecommerce_action = "add_to_cart"
        if exists(.properties.product_id) {
          .properties.product_sku = .properties.product_id
        }
        if exists(.properties.price) {
          .properties.revenue = .properties.price
        }
        if !exists(.properties.currency) {
          .properties.currency = "USD"
        }
      }
      
      if event_name == "Purchase" || event_name == "purchase" {
        .event = "Purchase"
        .properties.event_category = "analytics"
        .properties.destination = "mixpanel"
        .properties.ecommerce_action = "purchase"
        if exists(.properties.total) {
          .properties.revenue = .properties.total
        }
        if exists(.properties.value) && !exists(.properties.total) {
          .properties.revenue = .properties.value
        }
        if !exists(.properties.currency) {
          .properties.currency = "USD"
        }
      }
      
      # FEATURE USAGE EVENTS
      if event_name == "Feature Used" {
        .properties.event_category = "analytics"
        .properties.destination = "mixpanel"
        .properties.interaction_type = "feature_usage"
      }

  format_for_mixpanel:
    type: remap
    inputs: ["enrich_for_mixpanel"]
    source: |
      # Get Mixpanel token using proper VRL error handling
      mixpanel_token, err = get_env_var("MIXPANEL_TOKEN")
      if err != null {
        log("Missing MIXPANEL_TOKEN environment variable", level: "error")
        abort
      }
      
      # Create Mixpanel event structure (different from PostHog)
      mixpanel_event = {
        "event": .event,
        "properties": .properties
      }
      
      # Add required Mixpanel properties
      mixpanel_event.properties.token = mixpanel_token
      mixpanel_event.properties.distinct_id = .distinct_id
      mixpanel_event.properties.time = to_unix_timestamp!(.timestamp, unit: "seconds")
      
      # Add HTTP context as Mixpanel properties
      if exists(.http_context) && is_object(.http_context) {
        if exists(.http_context.user_agent) {
          mixpanel_event.properties.user_agent = .http_context.user_agent
        }
        if exists(.http_context.ip) {
          mixpanel_event.properties.ip = .http_context.ip
        }
        if exists(.http_context.referrer) {
          mixpanel_event.properties.referrer = .http_context.referrer
        }
      }
      
      # Set the final event
      . = mixpanel_event

sinks:
  posthog:
    type: http
    inputs: ["format_for_posthog"]
    uri: "https://app.posthog.com/capture/"
    method: "post"
    encoding:
      codec: "json"
    compression: "gzip"
    batch:
      max_events: 50
      timeout_secs: 1
    request:
      retry_attempts: 3
      retry_initial_backoff_secs: 1
      retry_max_duration_secs: 30
      timeout_secs: 30
    buffer:
      type: "memory"
      max_events: 500
      when_full: "block"

  mixpanel:
    type: http
    inputs: ["format_for_mixpanel"]
    uri: "https://api-eu.mixpanel.com/track"
    method: "post"
    encoding:
      codec: "json"
    compression: "gzip"
    batch:
      max_events: 50
      timeout_secs: 1
    request:
      retry_attempts: 3
      retry_initial_backoff_secs: 1
      retry_max_duration_secs: 30
      timeout_secs: 30
    buffer:
      type: "memory"
      max_events: 500
      when_full: "block"